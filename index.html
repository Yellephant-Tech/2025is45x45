<html>
    <!-- 2025 by Thomas Colthurst -->
    <!-- Original at https://thomaswc.com/2025.html -->
    <!-- fork of Vessenes's version: https://vessenes.github.io/2025is45x45/ -->
    <title>150</title>
    <style>
        :root {
            --bg: #f6f1e7;
            --bg-accent: #dfe9e8;
            --ink: #1b1b1b;
            --muted: #5c5c5c;
            --accent: #e45d3b;
            --accent-2: #1f7a73;
            --card: #ffffff;
            --shadow: rgba(15, 23, 42, 0.12);
            --gap: 6px;
            --radius: 14px;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            color: var(--ink);
            font-family: "Avenir Next", "Gill Sans", "Optima", "Trebuchet MS", sans-serif;
            background:
                radial-gradient(1200px 800px at 10% 0%, #fcead0 0%, transparent 60%),
                radial-gradient(900px 600px at 100% 0%, #d9efe8 0%, transparent 55%),
                var(--bg);
        }

        #app {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .topbar {
            position: sticky;
            top: 0;
            z-index: 1000;
            background: rgba(246, 241, 231, 0.9);
            border-bottom: 1px solid rgba(0, 0, 0, 0.06);
            backdrop-filter: blur(8px);
        }

        .topbar-content {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: nowrap;
            justify-content: space-between;
            padding: 10px 18px;
        }

        @media (max-width: 768px) {
            .shortcuts {
                display: none;
            }
        }

        .title {
            font-size: clamp(16px, 2vw, 22px);
            font-weight: 700;
            letter-spacing: 0.2px;
        }

        .page-footer {
            text-align: center;
            padding: 12px 18px;
            color: var(--muted);
            font-size: clamp(10px, 1.2vw, 12px);
        }

        .page-footer a {
            color: var(--accent-2);
        }

        #status {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
            font-size: clamp(12px, 1.6vw, 16px);
        }

        .stat {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-weight: 600;
        }

        #deselect {
            border: none;
            background: var(--accent);
            color: #fff;
            padding: 8px 14px;
            border-radius: 999px;
            font-weight: 600;
            cursor: pointer;
        }

        #deselect:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #filter-input {
            border: 1px solid rgba(0, 0, 0, 0.15);
            border-radius: 999px;
            padding: 8px 14px;
            min-width: min(260px, 70vw);
            font-size: clamp(12px, 1.6vw, 16px);
            background: #fff;
        }

        .layout {
            display: block;
            padding: 16px 18px 22px;
        }

        #board-wrapper {
            flex: 1 1 auto;
            background: rgba(255, 255, 255, 0.7);
            border-radius: var(--radius);
            border: 1px solid rgba(0, 0, 0, 0.08);
            box-shadow: 0 10px 30px var(--shadow);
            overflow: auto;
            max-height: calc(100vh - 140px);
        }

        #board-wrapper.shuffle-flash {
            animation: shuffleFlash 0.6s ease;
        }

        #board {
            padding: 14px;
        }

        #priority-lane {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 220px));
            gap: 12px;
            margin: 14px;
            justify-content: start;
            position: relative;
            z-index: 2;
        }

        .cluster-item {
            width: 100%;
            animation: dropIn 0.35s ease;
            transition: transform 180ms cubic-bezier(0.2, 0.8, 0.2, 1);
            position: relative;
            z-index: 1;
        }

        .cluster-item:has(.expanded),
        .cluster-item.expanded {
            z-index: 1000;
        }

        .cluster-item .bigbut {
            width: 100%;
        }

        .cluster-item.recent {
            animation: recentPulse 0.8s ease;
            box-shadow: 0 0 18px rgba(31, 122, 115, 0.35);
            border-radius: 12px;
        }

        table#the_table {
            border-collapse: separate;
            border-spacing: var(--gap);
        }

        td.tile-cell {
            vertical-align: top;
            position: relative;
            z-index: 1;
        }

        td.tile-cell:has(.expanded),
        td.tile-cell.expanded {
            z-index: 1000;
        }

        button.bigbut {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 6px;
            width: 100%;
            min-width: clamp(90px, 8vw, 140px);
            min-height: clamp(56px, 6vw, 90px);
            max-height: 90px;
            padding: 8px 10px;
            font-size: clamp(11px, 1.4vw, 16px);
            font-weight: 600;
            text-align: center;
            color: var(--ink);
            background: var(--card);
            border-radius: 12px;
            border: 1px solid rgba(0, 0, 0, 0.12);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.08);
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
            position: relative;
            overflow: visible;
            z-index: 2;
        }

        button.bigbut:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 14px rgba(0, 0, 0, 0.12);
        }

        button.bigbut.selected {
            outline: 2px solid var(--accent);
            box-shadow: 0 0 0 3px rgba(228, 93, 59, 0.25);
            animation: selectedWiggle 0.8s ease-in-out infinite;
        }

        #pin-zone {
            position: sticky;
            top: 0;
            left: 0;
            z-index: 500;
            background: rgba(246, 241, 231, 0.95);
            backdrop-filter: blur(4px);
            padding: 8px 14px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            display: none;
        }

        #pin-zone:not(:empty) {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #pin-zone .pin-label {
            font-size: 12px;
            color: var(--muted);
            font-weight: 600;
        }

        #pin-zone button.bigbut {
            min-width: 140px;
            max-width: 220px;
        }

        .pinned-original {
            opacity: 0.3;
        }

        button.bigbut:disabled {
            opacity: 0.55;
            cursor: not-allowed;
        }

        button.bigbut.completed {
            opacity: 0.9;
            cursor: default;
        }

        button.bigbut.juice-pop {
            animation: juicePop 0.35s ease;
        }

        .cluster-summary {
            font-weight: 700;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .cluster-count {
            color: var(--accent);
            font-weight: 700;
        }

        .cluster-full {
            max-height: 0;
            opacity: 0;
            overflow: hidden;
            transition: max-height 0.2s ease, opacity 0.2s ease, transform 0.2s ease;
            font-size: clamp(10px, 1.2vw, 13px);
            color: var(--muted);
            position: absolute;
            left: 0;
            right: 0;
            top: calc(100% + 6px);
            background: #fff;
            border: 1px solid rgba(0, 0, 0, 0.12);
            border-radius: 10px;
            padding: 8px 10px;
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.15);
            transform: translateY(-6px);
            z-index: 10;
        }

        button.bigbut.expanded {
            z-index: 100;
        }

        button.bigbut.expanded .cluster-full {
            max-height: 180px;
            opacity: 1;
            transform: translateY(0);
            overflow: auto;
        }

        .matched-card {
            border-radius: 12px;
            border: 1px solid rgba(0, 0, 0, 0.12);
            padding: 10px 12px;
            background: var(--card);
            box-shadow: 0 6px 14px rgba(0, 0, 0, 0.08);
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .matched-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            font-weight: 700;
            background: none;
            border: none;
            padding: 0;
            text-align: left;
            cursor: pointer;
            font-size: clamp(13px, 1.6vw, 16px);
        }

        .matched-count {
            color: var(--accent-2);
            font-weight: 700;
        }

        .matched-words {
            max-height: 0;
            opacity: 0;
            overflow: hidden;
            transition: max-height 0.35s ease, opacity 0.35s ease;
            font-size: clamp(11px, 1.4vw, 14px);
            color: var(--muted);
        }

        .matched-card.expanded .matched-words {
            max-height: 520px;
            opacity: 1;
        }

        .shake {
            animation: shake 0.5s;
            animation-iteration-count: 1;
        }

        .red {
            color: var(--accent);
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        .is-hidden {
            display: none;
        }

        .shortcuts {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: flex-start;
            font-size: clamp(11px, 1.3vw, 14px);
            color: var(--muted);
        }

        .shortcut-key {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(0, 0, 0, 0.1);
            font-weight: 600;
        }

        .keycap {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 22px;
            padding: 2px 6px;
            border-radius: 6px;
            background: #1b1b1b;
            color: #fff;
            font-size: 12px;
            font-weight: 700;
            letter-spacing: 0.5px;
        }

        #reset-indicator {
            position: fixed;
            left: 50%;
            bottom: 24px;
            transform: translateX(-50%) translateY(10px);
            background: rgba(27, 27, 27, 0.92);
            color: #fff;
            padding: 10px 14px;
            border-radius: 999px;
            display: flex;
            align-items: center;
            gap: 10px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            z-index: 2000;
        }

        #reset-indicator.active {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        #reset-indicator.done {
            animation: resetPulse 0.6s ease;
        }

        .reset-bar {
            width: 120px;
            height: 6px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.2);
            overflow: hidden;
            position: relative;
        }

        .reset-bar::after {
            content: "";
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #ffb347, #ff5f6d);
            border-radius: inherit;
        }

        #reset-indicator.holding .reset-bar::after {
            animation: holdFill 1s linear forwards;
        }

        .score-pop {
            animation: scorePop 0.3s ease;
        }

        #fireworks {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10000;
        }

        @media (max-width: 980px) {
            #board-wrapper {
                max-height: none;
            }
        }

        @keyframes shake {
            0% { transform: translateX(1px) rotate(0deg); }
            10% { transform: translateX(-1px) rotate(-1deg); }
            20% { transform: translateX(-3px) rotate(1deg); }
            30% { transform: translateX(3px) rotate(0deg); }
            40% { transform: translateX(1px) rotate(1deg); }
            50% { transform: translateX(-1px) rotate(-1deg); }
            60% { transform: translateX(-3px) rotate(0deg); }
            70% { transform: translateX(3px) rotate(-1deg); }
            80% { transform: translateX(-1px) rotate(1deg); }
            90% { transform: translateX(1px) rotate(0deg); }
            100% { transform: translateX(1px) rotate(-1deg); }
        }

        @keyframes dropIn {
            from { opacity: 0; transform: translateY(-6px) scale(0.98); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        @keyframes juicePop {
            0% { transform: scale(1); }
            45% { transform: scale(1.08) rotate(-1deg); }
            100% { transform: scale(1); }
        }

        @keyframes scorePop {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        @keyframes holdFill {
            from { width: 0%; }
            to { width: 100%; }
        }

        @keyframes resetPulse {
            0% { transform: translateX(-50%) scale(1); }
            40% { transform: translateX(-50%) scale(1.06); }
            100% { transform: translateX(-50%) scale(1); }
        }

        @keyframes shuffleFlash {
            0% { box-shadow: 0 0 0 rgba(228, 93, 59, 0); }
            40% { box-shadow: 0 0 24px rgba(228, 93, 59, 0.35); }
            100% { box-shadow: 0 0 0 rgba(228, 93, 59, 0); }
        }

        @keyframes recentPulse {
            0% { transform: scale(1); box-shadow: 0 0 0 rgba(31, 122, 115, 0); }
            40% { transform: scale(1.02); box-shadow: 0 0 18px rgba(31, 122, 115, 0.35); }
            100% { transform: scale(1); box-shadow: 0 0 0 rgba(31, 122, 115, 0); }
        }

        @keyframes selectedWiggle {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(-1.5deg); }
            75% { transform: rotate(1.5deg); }
        }

        @keyframes matchBurst {
            0% { transform: scale(1); box-shadow: 0 0 0 rgba(31, 122, 115, 0); }
            30% { transform: scale(1.12) rotate(-2deg); box-shadow: 0 0 20px rgba(31, 122, 115, 0.5); }
            60% { transform: scale(1.05) rotate(1deg); box-shadow: 0 0 30px rgba(31, 122, 115, 0.3); }
            100% { transform: scale(1) rotate(0); box-shadow: 0 0 0 rgba(31, 122, 115, 0); }
        }

        @keyframes goldPulse {
            0%, 100% { box-shadow: 0 0 8px rgba(255, 193, 7, 0.4); }
            50% { box-shadow: 0 0 20px rgba(255, 193, 7, 0.7); }
        }

        /* Match burst animation */
        button.bigbut.match-burst {
            animation: matchBurst 0.5s ease-out;
        }

        /* Progress glow - intensifies as cluster grows */
        button.bigbut.glow-mild {
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.08), 0 0 8px rgba(255, 193, 7, 0.3);
        }
        button.bigbut.glow-medium {
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.08), 0 0 12px rgba(255, 193, 7, 0.5);
            border-color: rgba(255, 193, 7, 0.4);
        }
        button.bigbut.glow-strong {
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.08), 0 0 18px rgba(255, 193, 7, 0.7);
            border-color: rgba(255, 193, 7, 0.6);
            background: linear-gradient(135deg, #fffef5 0%, #fff9e6 100%);
        }
        button.bigbut.glow-intense {
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.08), 0 0 25px rgba(255, 193, 7, 0.85);
            border-color: rgba(255, 193, 7, 0.8);
            background: linear-gradient(135deg, #fffdf0 0%, #fff4cc 100%);
            animation: goldPulse 1.5s ease-in-out infinite;
        }
    </style>
    <body>
        <canvas id="fireworks"></canvas>
<div id="app">
    <header class="topbar">
        <div class="topbar-content">
            <div class="title">Make 15 groups of 10!</div>
            <div class="shortcuts">
                <span class="shortcut-key"><span class="keycap">R</span> Hold to reset</span>
                <span class="shortcut-key"><span class="keycap">S</span> Shuffle</span>
                <span class="shortcut-key"><span class="keycap">/</span> Search</span>
                <span class="shortcut-key"><span class="keycap">Esc</span> Clear search</span>
            </div>
            <div id="status">
                <span class="stat">Score: <span id="score">0</span></span>
                <span class="stat">Mistakes: <span id="mistakes">0</span></span>
                <label class="sr-only" for="filter-input">Filter words</label>
                <input id="filter-input" type="search" placeholder="Type / to search" autocomplete="off" />
            </div>
        </div>
    </header>
    <div class="layout">
        <div id="board-wrapper">
            <div id="pin-zone"></div>
            <div id="priority-lane"></div>
            <div id="board"></div>
        </div>
    </div>
    <footer class="page-footer">
        Forked from <a href="https://thomaswc.com/2025.html">thomaswc.com/2025.html</a>. All modifications &copy; 2025 Peter Vessenes, <a href="https://creativecommons.org/publicdomain/zero/1.0/" target="_blank" rel="noopener">CC0 1.0</a>. Fork me at <a href="https://github.com/vessenes/2025is45x45">github.com</a>
    </footer>
</div>
<div id="reset-indicator">
    <span id="reset-label">Hold R to reset</span>
    <div class="reset-bar"></div>
</div>

    </body>
        <script>
        // Bugs: 
        // 1) Unicode not rendering properly inside buttons on Chrome.
        // Feature requests:
        // 1) Don't penalize already guessed.
        
        // Globals
        const M = 15;  // Board size
            
        var score = 0;
        var mistakes = 0;
        
        var selected = 0;  // The currently selected button, if any.
        
        var wordlist = [];  // Actually, a list of (word, category) pairs
        var resetHoldTimer = null;


        // The categories.
        
        var cats = {};
            
            // #1.
            cats["Board Games on the LO Board Game Shelf"] = ["Fire Tower", "Spy Alley", "Dungeons & Dragons Starter Set", "Small World", "Patchwork", "Lord of the Rings: Duel for Middle Earth", "Inhuman Circumstances", "Splendor", "Life", "Cat in a Box"];
            
            // #2
            cats["Graphic Novels/Series that Focus on Food"] = ["What Did You Eat Yesterday?", "Our Not-So-Lonely Planet Travel Guide", "She Loves to Cook and She Loves to Eat", "Confessions of a Shy Baker", "Joy of Snacking: A Graphic Memoir", "Relish", "Delicious in Dungeon", "Not Love But Delicious Foods Make Me So Happy", "Emma Dreams of Stars: inside the gourmet guide", "Meal"];
            
            // #3.
            cats["Queer Characters in Dragon Age"] = ["Leliana", "Zevran", "Merrill", "Anders", "Fenris", "Isabela", "Iron Bull", "Josephine", "Dorian", "Sara"];

            // #4.
            cats["oil paint colors"] = ["titanium white", "cadmium yellow", "cadmium red", "phthalo blue", "french ultramarine", "van dyke brown", "alizarin crimson", "burnt sienna", "lamp black", "emerald green"];
            
            // #5
            cats["dnd classes"] = ["barbarian", "bard", "claric", "fighter", "monk", "paladin", "ranger", "sorcerer", "wizard", "rogue"];

            // #6
            cats["Types of Numbers"] = ["Natural", "Whole", "Rational", "Real", "Irrational", "Imaginary", "Complex", "P-adic", "Decimal", "Binary", "Positive", "Negative", "Even", "Odd", "Prime", "Composite", "Triangular", "Square", "Fibonacci", "Perfect", "Algebraic", "Transcendental", "Transfinite", "Ordinal", "Surreal", "Computable", "Constructible", "Hypercomplex", "Nonstandard", "Concrete", "Abstract", "Denominate", "Abundant", "Bell", "Carmichael", "Catalan", "Deficient", "Euler", "Factorial", "Figurate", "Happy", "Hyperperfect", "Lucky", "Lucas", "Motzkin", "Padovan", "Partition", "Practical", "Pseudoprime", "Semiprime", "Superperfect", "Ulam"];

             // #7.  Censored:  Drake (Bird).  Needs 1 more
             cats["Memes"] = ["Distracted boyfriend", "Change my mind", "Is this a pigeon?", "Unsure Fry", "This is fine", "Kermit sips Lipton", "World's most interesting man", "Batman slapping Robin", "Expanding Brain", "Two buttons", "One does not simply", "Disaster girl", "Woman yelling at cat", "Gru's plan", "I am once again asking you for your support", "Tuxedo Winnie the Pooh", "Leonardo Decaprio Cheers", "Marked Safe From", "Bad Luck Brian", "They're the same picture", "All The Things", "Four Panel Anakin Padme", "Grumpy Cat", "Winter is Coming", "That Would Be Great", "Clown Applying Makeup", "Picard Facepalm", "Philosoraptor", "Matrix Morpheus", "Hard to Swallow Pills", "Laughing Men in Suits", "Too Damn High", "Am I The Only One Around Here", "Spiderman pointing at Spiderman", "I Should Buy a Boat Cat", "Sparta Leonidas", "See Nobody Cares", "Shut Up and Take My Money", "Everybody loses their minds", "Out of Touch Skinner", "Success Kid", "Overly attached girlfriend", "You know I'm something of a scientist myself", "How do you do fellow kids", "Condescending Willy Wonka"];
             
             // #8.  Censored: Wolverine (MCU Character), Goat (Cheese), Jaguar (Car)
             cats["Mammals"] = ["Tenrec", "Shrew", "Mole", "Dog", "Fox", "Wolf", "Jackal", "Bear", "Skunk", "Badger", "Otter", "Weasel", "Raccoon", "Coati", "Seal", "Walrus", "Sea Lion", "Civet", "Cat", "Lion", "Tiger", "Leopard", "Lynx", "Cougar", "Cheetah", "Linsang", "Hyena", "Mongoose", "Camel", "Pig", "Warthog", "Peccary", "Hippopotamus", "Whale", "Narwhal", "Beluga", "Dolphin", "Porpoise", "Chevrotain", "Giraffe", "Okapi", "Moose", "Caribou", "Deer", "Buffalo", "Antelope", "Gazelle", "Sheep", "Bat", "Armadillo", "Mice", "Lemur", "Possum", "Wombat", "Kangaroo", "Hedgehog", "Rabbit", "Horse", "Zebra", "Rhinoceros", "Anteater", "Sloth", "Monkey", "Elephant", "Squirrel", "Mouse", "Beaver", "Gopher", "Rat", "Porcupine", "Aardvark", "Manatee"];

              // #9.  Censored:  Triangle (Type of Number)
              cats["Musical Instruments"] = ["Guitar", "Violin", "Drums", "Bass", "Oboe", "Piano", "Synthesizer", "Cello", "Harp", "Viola", "Banjo", "Mandolin", "Ukulele", "Lute", "Sitar", "Lyre", "Flute", "Clarinet", "Saxophone", "Bassoon", "Recorder", "Piccolo", "Trumpet", "Trombone", "Tuba", "French horn", "Bugle", "Organ", "Harpsichord", "Tambourine", "Xylophone", "Accordion", "Bagpipes", "Cymbal", "Didgeridoo", "Fiddle", "Glockenspiel", "Gong", "Harmonica", "Ocarina", "Zither", "Whistle", "Theremin", "Vibraphone", "Timpani"];
              
              // #10
              cats["Dog Breeds"] = ["French bulldog", "Labrador retriever", "Golden retriever", "German shepherd", "Poodle", "Dachshund", "Beagle", "Rottweiler", "Bulldog", "German shorthaired pointer", "Yorkshire terrier", "Australian shepherd", "Cavalier King Charles Spaniel", "Cane Corso", "Pembroke Welsh Corgi", "Doberman Pinscher", "Boxer", "Miniature schnauzer", "Bernese Mountain Dog", "Shih Tzu", "Great Dane", "Pomeranian", "Boston Terrier", "Miniature American Shepherd", "Havanese", "Siberian Husky", "Chihuahua", "English Springer Spaniel", "Shetland Sheepdog", "Border Collie", "Brittany", "Cocker Spaniel", "Belgian Malinois", "Basset Hound", "Vizsla", "English Cocker Spaniel", "Maltese", "Pug", "Collie", "Mastiff", "West Highland White Terrier", "Shiba Inu", "Rhodesian Ridgeback", "Papillon", "Portuguese Water Dog", "Dalmatian", "Scottish Terrier", "Bloodhound", "Saint Bernard", "Irish Setter"];
              
              // #11 Censored: Skeleton (D&D Monster)
              cats["Olympic Sports"] = ["Swimming", "Gymnastics", "Pentathlon", "Diving", "Wrestling", "Rowing", "Boxing", "Soccer", "Judo", "Archery", "Tennis", "Volleyball", "Weightlifting", "Skateboarding", "Triathlon", "Badminton", "Fencing", "Sailing", "Surfing", "Equestrian", "Water polo", "Field hockey", "Basketball", "Bicycling", "Karate", "Ice hockey", "Lacrosse", "Baseball", "Biathlon", "Table tennis", "Figure skating", "Golf", "Bobsleigh", "Shooting", "Cricket", "Curling", "Luge", "Canoeing", "Football", "Rugby sevens", "Softball", "Taekwondo", "Squash", "Sport climbing", "Skiing"];
              
              // #12.  Censored:  Dragon (tree), Skeleton (Olympic Sport), Zombie (Drink)
              cats["D&D Monsters"] = ["Beholder", "Devil", "Displacer beast", "Gelatinous cube", "Hell hound", "Lich", "Mimic", "Mind flayer", "Mummy", "Owlbear", "Rust monster", "Grue", "Demon", "Tarrasque", "Bugbear", "Carrion crawler", "Chimera", "Cockatrice", "Air Elemental", "Fire Elemental", "Water Elemental", "Earth Elemental", "Djinn", "Ghost", "Ghoul", "Hill Giant", "Gnoll", "Goblin", "Golem", "Harpy", "Hobgoblin", "Hydra", "Imp", "Werewolf", "Manticore", "Medusa", "Minotaur", "Ogre", "Ochre jelly", "Troll", "Umber hulk", "Vampire", "Wight", "Wraith", "Bulette"];
              
              // #13.  Censored: Bard (Google Product)
              cats["Tolkien Character"] = ["Aragorn", "Gandalf", "Frodo", "Sauron", "Galadriel", "Gollum", "Arwen", "Legolas", "Bilbo", "Elrond", "Pippin", "Eowyn", "Gimli", "Samwise", "Saruman", "Boromir", "Tom Bombadil", "Merry", "Theoden", "Faramir", "Eomer", "Treebeard", "Grima", "Denethor", "Radagast", "Glorfindel", "Celeborn", "Thengel", "Goldberry", "Shelob", "Gaffer Gamgee", "Lobelia Sackville-Baggins", "Thorin Oakenshield", "Smaug", "Beorn", "Balin", "Ori", "Dwalin", "Fili", "Kili", "Oin", "Gloin", "Dori", "Nori", "Bifur", "Bofur", "Bombur"];
              
              // #14
              cats["Cartoonists"] = ["Scott Adams", "Robert Crumb", "Matt Groening", "Gary Larson", "Charles Schulz", "Alison Bechdel", "Jim Davis", "Garry Trudeau", "Walt Kelly", "Bill Watterson", "Marjane Satrapi", "Herge", "Mike Judge", "Lynn Johnston", "Charles Addams", "Chuck Jones", "Bil Keane", "George Herriman", "Bob Kane", "Jack Kirby", "Joseph Barbera", "Walt Disney", "John Byrne", "Jay Ward", "Art Spiegelman", "Scott McCloud", "Harvey Pekar", "Edward Gorey", "Berkeley Breathed", "Will Eisner", "Rube Goldberg", "Larry Gonick", "Shel Silverstein", "Dr. Seuss", "Osamu Tezuka", "Quino", "Sergio Aragones", "Randall Munroe", "Roz Chast", "Phil Foglio", "Zach Weinersmith", "Ryan North", "Mike Krahulik", "Rich Burlew", "Jeph Jacques", "Kate Beaton", "Allie Brosch" ];
       
            // Functions
            
            function clearPinZone() {
              const pinZone = document.getElementById("pin-zone");
              pinZone.innerHTML = "";
              // Remove dimming from any pinned originals
              document.querySelectorAll(".pinned-original").forEach(el => {
                el.classList.remove("pinned-original");
              });
            }

            function deselect() {
              if (selected != 0) {
                selected.classList.remove("selected");
                clearPinZone();
                selected = 0;
              }
            }

            function pinSelected(button) {
              const pinZone = document.getElementById("pin-zone");
              clearPinZone();

              // Create a visual clone for the pin zone
              const clone = button.cloneNode(true);
              clone.classList.add("selected");
              clone.classList.remove("pinned-original");

              // Clone click delegates to original
              clone.onclick = (e) => {
                e.stopPropagation();
                button.click();
              };

              // Add label and clone to pin zone
              const label = document.createElement("span");
              label.className = "pin-label";
              label.textContent = "Selected:";
              pinZone.appendChild(label);
              pinZone.appendChild(clone);

              // Dim the original
              button.classList.add("pinned-original");
            }

            function wireButton(button) {
              button.addEventListener("mouseenter", () => {
                if (!button.cluster || button.cluster.length <= 1) {
                  return;
                }
                if (button.hoverTimer) {
                  clearTimeout(button.hoverTimer);
                }
                button.hoverTimer = setTimeout(() => {
                  button.classList.add("expanded");
                  const wrapper = button.closest(".cluster-item") || button.closest("td.tile-cell");
                  if (wrapper) wrapper.classList.add("expanded");
                }, 150);
              });
              button.addEventListener("mouseleave", () => {
                if (button.hoverTimer) {
                  clearTimeout(button.hoverTimer);
                }
                button.classList.remove("expanded");
                const wrapper = button.closest(".cluster-item") || button.closest("td.tile-cell");
                if (wrapper) wrapper.classList.remove("expanded");
              });
              button.onclick = function() {
                  let didMatch = false;
                  if (selected == button) {
                    deselect();
                    return;
                  }
                  button.classList.add("selected");

                  if (selected == 0) {
                      selected = button;
                      pinSelected(button);
                      return;
                  }

                  if (button.category == selected.category) {

                    firstbut = button;
                    secondbut = selected;

                    // Deselect and clear pin zone
                    clearPinZone();
                    selected.classList.remove("selected");
                    button.classList.remove("selected");
                    selected = 0;
                    didMatch = performMatch(firstbut, secondbut);

                  } else {
                    mistakes = mistakes + 1;
                    document.getElementById("mistakes").textContent = mistakes;
                    bumpStat("mistakes");

                    // Immediately deselect and clear pin zone
                    clearPinZone();
                    selected.classList.remove("selected");
                    button.classList.remove("selected");

                    // Shake both
                    button.classList.add('shake');
                    selected.classList.add('shake');

                    button.addEventListener('animationend', () => {
                      button.classList.remove('shake');
                    }, { once: true });

                    old_selected = selected;
                    old_selected.addEventListener('animationend', () => {
                      old_selected.classList.remove('shake');
                    }, { once: true });

                    selected = 0;
                  }
                  if (!didMatch) {
                    saveState();
                  }
                  if (score == 1980) {
                      window.alert("You win!!");
                      startFireworks();
                  }
              };
            }

            function buildClusterSummary(cluster) {
              if (cluster.length == 2) {
                return `${cluster[0]}; ${cluster[1]}`;
              }
              return `${cluster[0]}, ${cluster[1]}, ... <span class="cluster-count">[${cluster.length}]</span>`;
            }

            function updateButtonSearch(button) {
              const cluster = button.cluster || [];
              const text = cluster.length === 1 ? cluster[0].toLowerCase() : "";
              button.dataset.search = text;
              const wrapper = button.closest(".cluster-item");
              if (wrapper) {
                wrapper.dataset.search = text;
              }
            }

            function updateGlowClass(button) {
              const cluster = button.cluster || [];
              const len = cluster.length;
              button.classList.remove("glow-mild", "glow-medium", "glow-strong", "glow-intense");
              if (len >= 35) {
                button.classList.add("glow-intense");
              } else if (len >= 25) {
                button.classList.add("glow-strong");
              } else if (len >= 15) {
                button.classList.add("glow-medium");
              } else if (len >= 5) {
                button.classList.add("glow-mild");
              }
            }

            function setButtonLabel(button) {
              const cluster = button.cluster || [];
              if (cluster.length <= 1) {
                button.textContent = cluster[0] || "";
                button.title = "";
                updateButtonSearch(button);
                updateGlowClass(button);
                return;
              }
              const summary = buildClusterSummary(cluster);
              const full = cluster.join(", ");
              button.innerHTML = `<div class="cluster-summary">${summary}</div><div class="cluster-full">${full}</div>`;
              updateButtonSearch(button);
              updateGlowClass(button);
            }

            function moveClusterToPriority(button) {
              if (!button || !button.cluster || button.cluster.length < 2) {
                return;
              }
              const list = document.getElementById("priority-lane");
              if (!list) {
                return;
              }
              let wrapper = button.closest(".cluster-item");
              if (!wrapper) {
                wrapper = document.createElement("div");
                wrapper.className = "cluster-item";
                wrapper.appendChild(button);
                list.appendChild(wrapper);
                const td = button.closest("td");
                if (td) {
                  td.remove();
                }
              }
              list.querySelectorAll(".cluster-item.recent").forEach(item => {
                item.classList.remove("recent");
              });
              wrapper.classList.add("recent");
              wrapper.scrollIntoView({ behavior: "smooth", block: "nearest" });
              sortPriorityLane();
              updateButtonSearch(button);
            }

            function removeButton(button) {
              if (!button) {
                return;
              }
              const wrapper = button.closest(".cluster-item");
              if (wrapper) {
                wrapper.remove();
                return;
              }
              const td = button.closest("td");
              if (td) {
                td.remove();
              }
            }

            function createClusterButton(category, cluster) {
              const button = document.createElement("button");
              button.className = "bigbut";
              button.category = category;
              button.cluster = cluster;
              setButtonLabel(button);
              wireButton(button);
              return button;
            }

            function bumpStat(id) {
              const el = document.getElementById(id);
              if (!el) {
                return;
              }
              el.classList.remove("score-pop");
              void el.offsetWidth;
              el.classList.add("score-pop");
            }

            function clearSearch() {
              const input = document.getElementById("filter-input");
              if (!input) {
                return;
              }
              input.value = "";
            }

            function sortPriorityLane() {
              const list = document.getElementById("priority-lane");
              if (!list) {
                return;
              }
              const items = Array.from(list.children);
              if (items.length <= 1) {
                return;
              }
              const firstRects = new Map(items.map(item => [item, item.getBoundingClientRect()]));
              const sorted = items.slice().sort((a, b) => {
                const aBtn = a.querySelector("button.bigbut");
                const bBtn = b.querySelector("button.bigbut");
                const aLen = aBtn && aBtn.cluster ? aBtn.cluster.length : 0;
                const bLen = bBtn && bBtn.cluster ? bBtn.cluster.length : 0;
                if (bLen !== aLen) {
                  return bLen - aLen;
                }
                return items.indexOf(a) - items.indexOf(b);
              });
              sorted.forEach(item => list.appendChild(item));
              sorted.forEach(item => {
                const first = firstRects.get(item);
                const last = item.getBoundingClientRect();
                if (!first) {
                  return;
                }
                const dx = first.left - last.left;
                const dy = first.top - last.top;
                if (dx || dy) {
                  item.animate(
                    [
                      { transform: `translate(${dx}px, ${dy}px)` },
                      { transform: "translate(0, 0)" }
                    ],
                    {
                      duration: 180,
                      easing: "cubic-bezier(0.2, 0.8, 0.2, 1)"
                    }
                  );
                }
              });
            }

            function performMatch(firstbut, secondbut) {
              if (!firstbut || !secondbut) {
                return false;
              }
              if (!firstbut.category || !secondbut.category) {
                return false;
              }
              if (firstbut.category !== secondbut.category) {
                return false;
              }
              score = score + 1;
              firstbut.cluster = firstbut.cluster.concat(secondbut.cluster);
              setButtonLabel(firstbut);
              firstbut.classList.add("match-burst");
              firstbut.addEventListener("animationend", () => {
                firstbut.classList.remove("match-burst");
              }, { once: true });
              if (firstbut.cluster.length == 45) {
                finishCategory(firstbut);
              } else {
                moveClusterToPriority(firstbut);
                clearSearch();
                applyFilter();
              }
              document.getElementById("score").textContent = score;
              bumpStat("score");
              removeButton(secondbut);
              saveState();
              return true;
            }

            function shuffleBoard() {
              const table = document.getElementById("the_table");
              if (!table) {
                return;
              }
              const cells = [];
              const buttons = [];
              for (let i = 0, row; row = table.rows[i]; i++) {
                for (let j = 0, col; col = row.cells[j]; j++) {
                  const button = col.firstElementChild;
                  if (!button) {
                    continue;
                  }
                  cells.push(col);
                  buttons.push(button);
                }
              }
              if (buttons.length === 0) {
                return;
              }
              shuffleArray(buttons);
              for (let i = 0; i < cells.length; i++) {
                cells[i].innerHTML = "";
                cells[i].appendChild(buttons[i]);
              }
              const boardWrapper = document.getElementById("board-wrapper");
              if (boardWrapper) {
                boardWrapper.classList.remove("shuffle-flash");
                void boardWrapper.offsetWidth;
                boardWrapper.classList.add("shuffle-flash");
              }
              applyFilter();
              saveState();
            }

            function resetGame() {
              localStorage.clear();
              score = 0;
              mistakes = 0;
              selected = 0;
              clearPinZone();
              document.getElementById("score").textContent = score;
              document.getElementById("mistakes").textContent = mistakes;
              const input = document.getElementById("filter-input");
              input.value = "";
              input.blur();
              const matchedList = document.getElementById("priority-lane");
              matchedList.innerHTML = "";
              const board = document.getElementById("board");
              board.innerHTML = "";
              setUpBoard();
              putWordsInBoard();
              saveState();
              applyFilter();
              const boardWrapper = document.getElementById("board-wrapper");
              if (boardWrapper) {
                boardWrapper.classList.remove("shuffle-flash");
                void boardWrapper.offsetWidth;
                boardWrapper.classList.add("shuffle-flash");
              }
            }

            function showResetIndicator(state) {
              const indicator = document.getElementById("reset-indicator");
              const label = document.getElementById("reset-label");
              if (!indicator) {
                return;
              }
              if (label) {
                if (state === "done") {
                  label.textContent = "Reset complete!";
                } else if (state === "hold") {
                  label.textContent = "Hold R to reset";
                } else {
                  label.textContent = "Hold R to reset";
                }
              }
              indicator.classList.toggle("active", state === "hold" || state === "done");
              indicator.classList.toggle("holding", state === "hold");
              indicator.classList.toggle("done", state === "done");
              if (state === "done") {
                setTimeout(() => {
                  indicator.classList.remove("active", "holding", "done");
                }, 700);
              }
              if (state === "cancel") {
                indicator.classList.remove("active", "holding", "done");
              }
            }

            function shouldIgnoreHotkeys(target) {
              if (!target) {
                return false;
              }
              return target.tagName === "INPUT" || target.tagName === "TEXTAREA" || target.isContentEditable;
            }
            
            function stringToLightColor(str) {
              let hash = 0;
              for (let i = 0; i < str.length; i++) {
                hash = str.charCodeAt(i) + ((hash << 5) - hash);
              }

              const h = Math.abs(hash) % 360;
              const s = 70;
              const l = 80 + (Math.abs(hash) % 10); 

              const lDev = l / 100;
              const a = (s * Math.min(lDev, 1 - lDev)) / 100;
  
              const f = (n) => {
                const k = (n + h / 30) % 12;
                const color = lDev - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                return Math.round(255 * color).toString(16).padStart(2, "0");
              };

              return `#${f(0)}${f(8)}${f(4)}`;
            }
            
            function getRandomHexColor() {
              return '#' + Math.floor(Math.random() * 16777215).toString(16);
            }
            
            function finishCategory(b) {
              b.disabled = true;
              b.classList.add("completed");
              b.style.background = stringToLightColor(b.category);
              moveClusterToPriority(b);
              clearSearch();
              applyFilter();
            }
            
            function checkCategories() {
              const wordDict = new Map();
              // Check that each category has 45 entries.
              for (const [key, value] of Object.entries(cats)) {
                if (value.length < 45) {
                  alert(`Entry for ${key} has length ${value.length}`);
                }
                for (let i = 0; i < 45; i++) {
                  wordlist.push([value[i], key]);
                  if (wordDict.has(value[i])) {
                      alert(`Duplicate word ${value[i]}`);
                  }
                  else {
                      wordDict.set(value[i], true);
                  }
                }
              }
            }
            
            function shuffleArray(array) {
              for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
              }
            }
            
            function saveState() {
                localStorage.clear();
                
                localStorage.setItem('hasState', '1');
                localStorage.setItem('score', score + '');
                localStorage.setItem('mistakes', mistakes + '');
                const panelButtons = Array.from(document.querySelectorAll("#priority-lane button.bigbut"));
                const panelClusters = panelButtons
                  .filter(button => button && button.category && button.cluster)
                  .map(button => ({
                    category: button.category,
                    cluster: button.cluster
                  }));
                localStorage.setItem('panelClusters', JSON.stringify(panelClusters));
                
                var t = document.getElementById('the_table');
                for (let i = 0; i < t.rows.length; i++) {
                  let row = t.rows[i];
                  for (let j = 0; j < row.cells.length; j++) {
                    let cell = row.cells[j];
                    let button = cell.firstChild;
                    if (!button || !button.category || !button.cluster) {
                      continue;
                    }
                    localStorage.setItem(`${i}_${j}_category`, button.category);
                    localStorage.setItem(`${i}_${j}_cluster`, JSON.stringify(button.cluster));
                    localStorage.setItem(`${i}_${j}_innerHTML`, button.innerHTML);
                    localStorage.setItem(`${i}_${j}_title`, button.title);
                  }
                }
                
            }
            
            function putWordsInBoard() {
              shuffleArray(wordlist);
              document.getElementById("priority-lane").innerHTML = "";
              var currentWordIndex = 0;
              var table = document.getElementById("the_table");
              for (let i = 0, row; row = table.rows[i]; i++) {
                for (let j = 0, col; col = row.cells[j]; j++) {
                  var button = col.firstElementChild;
                  // button.pos = currentWordIndex;
                  button.textContent = wordlist[currentWordIndex][0];
                  button.category = wordlist[currentWordIndex][1];
                  button.cluster = [button.textContent];
                  setButtonLabel(button);
                  currentWordIndex += 1;
                }
              }
              applyFilter();
            }

            function applyFilter() {
              const input = document.getElementById("filter-input");
              const query = input.value.trim().toLowerCase();
              const table = document.getElementById("the_table");
              if (table) {
                for (let i = 0, row; row = table.rows[i]; i++) {
                  for (let j = 0, col; col = row.cells[j]; j++) {
                    const button = col.firstElementChild;
                    if (!button || button.textContent === "") {
                      col.classList.remove("is-hidden");
                      continue;
                    }
                    if (query === "") {
                      col.classList.remove("is-hidden");
                      continue;
                    }
                    const hay = button.dataset.search || "";
                    col.classList.toggle("is-hidden", !hay.includes(query));
                  }
                }
              }

              const priorityLane = document.getElementById("priority-lane");
              if (priorityLane) {
                const items = priorityLane.querySelectorAll(".cluster-item");
                items.forEach(item => {
                  if (query === "") {
                    item.classList.remove("is-hidden");
                    return;
                  }
                  const hay = item.dataset.search || "";
                  item.classList.toggle("is-hidden", !hay.includes(query));
                });
              }
            }
            
            function startFireworks() {
              const canvas = document.getElementById('fireworks');
              const ctx = canvas.getContext('2d');
              let w, h;
              let particles = [];
              let fireworks = [];

              function resize() {
                w = canvas.width = window.innerWidth;
                h = canvas.height = window.innerHeight;
              }
              window.addEventListener('resize', resize);
              resize();

              class Firework {
                constructor() {
                    this.x = Math.random() * w;
                    this.y = h;
                    this.tx = Math.random() * w;
                    this.ty = Math.random() * (h / 2);
                    this.color = `hsl(${Math.random() * 360}, 100%, 50%)`;
                    this.speed = 2 + Math.random() * 2;
                    this.angle = Math.atan2(this.ty - this.y, this.tx - this.x);
                    this.vx = Math.cos(this.angle) * this.speed;
                    this.vy = Math.sin(this.angle) * this.speed;
                    this.exploded = false;
                }

                update() {
                    this.x += this.vx;
                    this.y += this.vy;
                    if (this.vy < 0 && this.y < this.ty) {
                        this.explode();
                    } else if (this.vy > 0 && this.y > this.ty) { // Should technically not happen with simple upward movement
                         this.explode();
                    }
                }

                explode() {
                    this.exploded = true;
                    for (let i = 0; i < 50; i++) {
                        particles.push(new Particle(this.x, this.y, this.color));
                    }
                }

                draw() {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.fill();
                }
              }

              class Particle {
                constructor(x, y, color) {
                    this.x = x;
                    this.y = y;
                    this.color = color;
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 3;
                    this.vx = Math.cos(angle) * speed;
                    this.vy = Math.sin(angle) * speed;
                    this.alpha = 1;
                    this.decay = Math.random() * 0.015 + 0.005;
                }

                update() {
                    this.x += this.vx;
                    this.y += this.vy;
                    this.vy += 0.05; // gravity
                    this.alpha -= this.decay;
                }

                draw() {
                    ctx.save();
                    ctx.globalAlpha = this.alpha;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.fill();
                    ctx.restore();
                }
              }

              function loop() {
                // Clear with a trail effect
                ctx.globalCompositeOperation = 'destination-out';
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)'; 
                ctx.fillRect(0, 0, w, h);
                ctx.globalCompositeOperation = 'lighter';

                // Launch new firework randomly
                if (Math.random() < 0.05) {
                    fireworks.push(new Firework());
                }

                // Update and draw fireworks
                for (let i = fireworks.length - 1; i >= 0; i--) {
                    fireworks[i].update();
                    fireworks[i].draw();
                    if (fireworks[i].exploded) {
                        fireworks.splice(i, 1);
                    }
                }

                // Update and draw particles
                for (let i = particles.length - 1; i >= 0; i--) {
                    particles[i].update();
                    particles[i].draw();
                    if (particles[i].alpha <= 0) {
                        particles.splice(i, 1);
                    }
                }

                requestAnimationFrame(loop);
              }

              loop();
            }
            
            function setUpBoard() {
              // Just sets up the dom elements; does not put words in them.
              var b = document.getElementById("board");   
              const table = document.createElement('table');
              table.id = 'the_table';
              for (let i = 0; i < M; i++) {
                const tr = document.createElement('tr');
                tr.classList.add('.row');
                for (let j = 0; j < M; j++) {
                   const td = document.createElement('td');
                   td.className = "tile-cell";
                   const button = document.createElement('button');
                   button.className = "bigbut";
                   wireButton(button);
                   td.appendChild(button);
                   tr.appendChild(td);
                }
                table.appendChild(tr);
              }
              
              document.getElementById("board").appendChild(table);
            }
            
            function loadState() {
                const hasState = localStorage.getItem('hasState');
                if (!hasState) {
                    putWordsInBoard();
                    return;
                }
                score = Number(localStorage.getItem('score') || 0);
                document.getElementById("score").textContent = score;
                
                mistakes = Number(localStorage.getItem('mistakes') || 0);
                document.getElementById("mistakes").textContent = mistakes;
                
              const matchedList = document.getElementById("priority-lane");
              matchedList.innerHTML = "";
              const storedPanel = localStorage.getItem("panelClusters");
              if (storedPanel) {
                  try {
                      const parsed = JSON.parse(storedPanel) || [];
                      parsed.forEach(block => {
                          if (!block || !block.category || !Array.isArray(block.cluster)) {
                                return;
                            }
                            const button = createClusterButton(block.category, block.cluster);
                            if (block.cluster.length == 45) {
                                button.disabled = true;
                                button.classList.add("completed");
                                button.style.background = stringToLightColor(block.category);
                            }
                            const wrapper = document.createElement("div");
                            wrapper.className = "cluster-item";
                            wrapper.appendChild(button);
                            matchedList.appendChild(wrapper);
                            updateButtonSearch(button);
                        });
                  } catch (e) {
                      matchedList.innerHTML = "";
                  }
              }

                var table = document.getElementById("the_table");
                var cells_to_remove = [];
                var panel_moves = [];
                for (let i = 0, row; row = table.rows[i]; i++) {
                  for (let j = 0, col; col = row.cells[j]; j++) {
                    var button = col.firstElementChild;
                    // button.pos = currentWordIndex;
                    const storedCluster = localStorage.getItem(`${i}_${j}_cluster`);
                    if (storedCluster == null) {
                        cells_to_remove.push(col);
                        continue;
                    }
                    button.category = localStorage.getItem(`${i}_${j}_category`);
                    button.cluster = JSON.parse(storedCluster);
                    if (!button.category || !Array.isArray(button.cluster)) {
                        cells_to_remove.push(col);
                        continue;
                    }
                    setButtonLabel(button);
                    if (button.cluster.length > 1) {
                        panel_moves.push(button);
                    }
                  }
                }
                for (let i = 0; i < cells_to_remove.length; i++) {
                    cells_to_remove[i].remove();
                }
                for (let i = 0; i < panel_moves.length; i++) {
                    moveClusterToPriority(panel_moves[i]);
                }
                sortPriorityLane();
            }
            
            checkCategories();
            setUpBoard();
            loadState();
            document.getElementById("filter-input").addEventListener("input", applyFilter);
            applyFilter();
            document.addEventListener("keydown", (event) => {
              if (event.key === "Escape") {
                deselect();
                const input = document.getElementById("filter-input");
                input.value = "";
                input.blur();
                applyFilter();
                return;
              }
              if (shouldIgnoreHotkeys(event.target)) {
                return;
              }
              if (event.key === "/") {
                event.preventDefault();
                const input = document.getElementById("filter-input");
                input.focus();
                input.select();
                return;
              }
              if (event.key === "s" || event.key === "S") {
                shuffleBoard();
                return;
              }
              if (event.key === "r" || event.key === "R") {
                if (resetHoldTimer || event.repeat) {
                  return;
                }
                showResetIndicator("hold");
                resetHoldTimer = setTimeout(() => {
                  resetHoldTimer = null;
                  resetGame();
                  showResetIndicator("done");
                }, 1000);
              }
            });
            document.addEventListener("keyup", (event) => {
              if (event.key === "r" || event.key === "R") {
                if (resetHoldTimer) {
                  clearTimeout(resetHoldTimer);
                  resetHoldTimer = null;
                  showResetIndicator("cancel");
                }
              }
            });
        </script>

</html>
